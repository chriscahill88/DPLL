DPLL Description and Code  (9 and 14 points)
DPLL is a SAT-solving algorithm that determines if there exists a set of Boolean values that can be assigned to each integer such that it makes the problem true. Each formula, which makes up the problem, is made up of literals, which are each individual integer in a clause. A clause is a group of literals that combined together with OR statements makes a clause. A CNF is every clause combined together with AND statements. So, for a CNF to be true each clause must be true and for each clause to be true at least one literal in it must be true. So DPLL is a depth-first search tree that looks to find a correct combination of Boolean values that makes the CNF true. DPLL works by a couple of rules, the first step is to check if the CNF is already solved. Since DPLL starts with an empty assignment, which is the list of each variable and the truth value, it will always begin as not solved. It then checks if any clauses are empty, that is because if a clause is empty that means that the clause cannot be true thus a contradiction was made, and it will undo the previous step that was made. Then pure literal elimination happens, which means it looks at each variable and checks if each one is either all true or all false and if that statement is satisfied it assigns it the correct Boolean logic and ignores it in further steps. The next step is conflict resolution which is where the depth first search begins. The algorithm chooses a variable, in our case it is the variable that appears the most often, assigns it a Boolean variable, and then recursively calls itself. This recursion continues until it has run out of unassigned variables in which case None is returned to the function and the last step begins. Backtracking is what happens when an empty clause appears or there are no more unassigned variables. Backtracking can be described as checking to make sure the current path can lead to a valid solution and when it encounters a path that cannot lead to a valid solution it undoes its previous step and tries a different path. In this case, backtracking would first occur when every variable has been assigned to true and has not satisfied the solution in which case it would backtrack and test false for the previous variable. Backtracking is what allows the formula to test every possible combination of Boolean values for each variable. The program ends it either finds a valid solution or every combination has been tested and thus declares that no valid solution exists. 
The link to the github that contain the code can be found here. The code needs the direct path to the CNF 
https://github.com/chriscahill88/DPLL


walkSAT Description and Code (9 and 14 Points)
The implementation of walkSAT works by reading the CNF files and creating a variable clause that stores all of the clauses. The next function is the clauses_true which counts the number of true clauses. Next, we have a function that randomly selects a clause that evaluates as false and all the literals that equal false. The next function is very important as it creates the clause maps which stores all of the clauses and literals and also whether the variables are assigned true or false. Then the main function walkSAT begins which takes in variables clauses, the probability value, max flips, the number of clauses, the number of variables, and the file name. The walk sat algorithm works by taking a map named Literal_map which is stored with random True or false values for each variable and stores that map into another variable named clause map which will store the original map. It then checks if all the clauses are solved and if not it prints how many clauses are solved compared to the total. It then will select a random clause which is false and choose a variable in the clause and change it to true based on a probability that can be edited in the main code. Otherwise, if the probability fails it will perform a flip that will maximize the number of true clauses. This loop continues until the maximum number of flips is reached which can be edited in the main code or it finds a solution. The main code then loops through each file that starts with uf20-. 
The code for walkSAT can be found in the same link which can be found here
https://github.com/chriscahill88/DPLL


GSAT Description and Code (9 and 14 points)
GSAT works very similarly to walkSAT. GSAT works by reading the CNF files and creating a variable clause that stores all of the clauses. The next function is the clauses_true which counts the number of true clauses. Next, we have a function that randomly selects a clause that evaluates as false and all the literals that equal false. The next function is very important as it creates the clause maps which stores all of the clauses and literals and also whether the variables are assigned true or false. Then the main GSAT function is implemented which takes in parameters clauses, Max tries, and Max Flips. The code then begins a loop which is based on max tries and then nested inside of that loop it loops through max Flips. Within these loops, the literal map is made an values of true or false are assigned randomly to the variables. It then makes a map called clause map based of literal map which will store the map before changes are made to test for the best conditions. It then checks if the solution is found and if not it will iterate over each literal and finds out which flip finds the most amount of true clauses and will perform that flip. The literal and clause map are then updated to the best flip and then begins the loop over again. The main code then loops through each file that starts with uf20-. 
The code for GSAT can be found in the same link which can be found here
https://github.com/chriscahill88/DPLL

Graphs(15 points) 


   
The Graph above shows the number of satisfied clauses compared to the time in seconds it took for our DPLL, walkS AT, and GSAT programs to find a logic statement that proved the CNF was SAT. This file only shows the files uf20-….cnf since they contain only 20 unique variables and thus are able to be ran in a reasonable amount of time. The next closest amount of variables is in the uf50 files which contain 50 variables. Since the total number of possible moves for DPLL can be found by the formula 2^n+2^(n-1)+2^(n-2)…+2^n, when n = 50 that formula shows more than 2 quadrillion possible combinations while n = 20 is less than 2 million. With an average of around 15 seconds for 2 million options using that same ratio, 2 quadrillion options would be 15 billion seconds or 475 years to test every possible combination. With that being said that is why we only have graphs for the uf20 files.

Learning Outcomes(10)
I learned from this assignment how SAT solvers work and how to implement them. I also learned how to implement a depth-first search tree that reaches the bottom branch and thus can look at every single solution and find the correct one even if it is not super efficient. I also learned how search trees that use backtracking build the search tree. Instead of building every solution and then searching for the correct one they do both at the same time which could save memory space. I learned that DPLL is not as quick as walkSAT and GSAT but it is more accurate as in it will always find the correct combination if it exists. walkSAT and GSAT could both get unlucky and not find the correct combination of Boolean values but they do make up for the lack of accuracy with the speed at which they can solve. 

![image](https://github.com/chriscahill88/DPLL/assets/43705092/b29549ff-7635-411d-9cdd-af3c9a4ace5e)
