
#Created by Christopher Cahill on 10/2/2023 at 9:30 A.M.
#ChatGPT 3.5 was used to create the structure for this program and was given the prompt "Can you generate pseduocode for DPLL in python" on 10/2/2023 at  12:30 P.M.
#The lines below are the prompts given to ChatGPT 3.5 to help create this program on 10/3/2023 from 10 A.M - 7 P.M
#Can you edit the code so it pulls the formulas from a file called uf20-0156.cnf and the information in uf20-0156.cnf looks like c This Formular is generated by mcnf
#"Can you write a pseudo code for DPLL in Python?"
#"Can you add comments to each line?"
#"How would I print each literal and the boolean assigned to it?"
#"Can you add comments to this code?"
#"Can you add more comments to each line of the DPLL def?"
#"Can you add comments to this code?"
#"Can you edit this code so it takes in uf20-0157.cnf as the cnf and also works with the format of uf20-0157.cnf?"
#"I have this def that I know works with the .cnf file to extract all of the clauses correctly, how would i implement this into my code"
#"In this code does each literal get a new variable that is linked to it called is_negated that keeps track of it has a - sign in front"
#These prompts were given between the time of 2:30 P.M and 8:00 PM on 10/4/2023
#"Can you add this Collect data, for each formula and each run, on the CPU time taken, and the highest value of ​c​ (highest number of satisfied clauses for any assignment) found so the code can do that"
#"Can you edit that line such that it uses this code"
#"unassigned = next((v for clause in cnf for v, _ in clause if v not in assignment), None) Can you edit this line so it picks the literal that appears the most often"
#The rest of the code and edits were made by myself 
#The following link was used to help understand how DPLL works and how the code would look like https://davefernig.com/2018/05/07/solving-sat-in-python/
#The following two links were both used to help understand the structure of how DPLL should look and what functions were needed
#https://gist.github.com/davefernig/e670bda722d558817f2ba0e90ebce66f#file-dpll
#https://github.com/bwconrad/DPLL-SAT-Solver/blob/master/dpll.py

# Import necessary libraries
import pylab as plt #Making plots
import time #Keeping track of time
import os #Used for looping through folder 
import matplotlib.pyplot as plt #used for Plots

# Directory containing CNF files (EDIT for user specific files)
cnf_folder = "/Users/christopher/Desktop/XCode_Projects/PA3_Benchmarks/CNF Formulas/"
# Lists to store data
max_satisfied_clauses_list = []
current_dpll_times_list = []
# Function to read the CNF formula from a file
def read_cnf(file_name):
    cnf = []
    with open(file_name, 'r') as file:
        for line in file:
            # Skip comments and problem specification lines
            if line.startswith('c') or line.startswith('p'):
                continue
            # Break when '%' is encountered (end of clauses)
            if line.startswith('%'):
                break
            clause = set()  # Change to set
            literals = line.strip().split()[:-1]
            for literal in literals:
                value = int(literal)
                is_negated = False
                if value < 0:
                    value = abs(value)
                    is_negated = True
                clause.add((value, is_negated))  # Change to add
            cnf.append(clause)  # Append the set to cnf

    return cnf

# Function to check if a clause is true given an assignment
def is_clause_true(clause, assignment):
    for variable, is_negated in clause:
        if variable in assignment:
            if is_negated:
                value = not assignment[variable]
            else:
                value = assignment[variable]
            if value:
                return True
    return False

# DPLL algorithm for solving CNF formulas
def DPLL(cnf, assignment):
    global max_satisfied_clauses  # Define a global variable to keep track of max satisfied clauses
    max_satisfied_clauses = 0  # Initialize max_satisfied_clauses
    # Check if all clauses are true with the current assignment
    if all(is_clause_true(clause, assignment) for clause in cnf):
        num_satisfied_clauses = sum(1 for clause in cnf if is_clause_true(clause, assignment))  # Count satisfied clauses
        max_satisfied_clauses = max(max_satisfied_clauses, num_satisfied_clauses)  # Update max satisfied clauses if needed
        print("All clauses are true, returning assignment")
        return assignment

    # Check if there is an empty clause, indicating a conflict
    if any(len(clause) == 0 for clause in cnf):
        print("Found an empty clause, backtracking")
        return None

    literal_counts = {}
    for clause in cnf:
        for v, _ in clause:
            if v not in assignment:
                literal_counts[v] = literal_counts.get(v, 0) + 1

    # Sort literals based on their frequency, most frequent first
    sorted_literals = sorted(literal_counts.keys(), key=lambda x: literal_counts[x], reverse=True)

    # Find the first unassigned literal in the sorted list
    unassigned = next((v for v in sorted_literals if v not in assignment), None)





    # If no unassigned variable is found, the formula is satisfied
    if unassigned is None:
        return None

    # Try assigning the variable (v) as True
    new_assignment = dict(assignment)
    new_assignment[unassigned] = True
    result = DPLL(cnf, new_assignment)
    if result is not None:
        return result

    # Try assigning the variable (v) as False
    new_assignment = dict(assignment)
    new_assignment[unassigned] = False
    result = DPLL(cnf, new_assignment)
    if result is not None:
        return result

    # If both True and False assignments lead to conflicts, backtrack
    return None


# Function to get the variable from a literal
def get_variable_from_literal(literal):
    return abs(literal)
# Iterate over files in the folder
for file_name in os.listdir(cnf_folder):
    if file_name.startswith("uf20-0"):
        cnf_path = os.path.join(cnf_folder, file_name)
        cnf = read_cnf(cnf_path)

        assignment = {}
        print(f"Processing file: {file_name}")

        # Run DPLL algorithm and record time
        start = time.time()
        result = DPLL(cnf, assignment)
        stop = time.time()
        current_dpll_times = stop - start

        if result is not None:
            num_satisfied_clauses = sum(1 for clause in cnf if is_clause_true(clause, result))
            max_satisfied_clauses_list.append(num_satisfied_clauses)
            print("Satisfying assignment:", result)

        current_dpll_times_list.append(current_dpll_times)

# Read CNF formula from file
#Code for testing individual files
'''file_name = "/Users/christopher/Desktop/XCode_Projects/PA3_Benchmarks/CNF Formulas/uf20-0157.cnf"
cnf = read_cnf(file_name)  # Call read_cnf function

# Initialize assignment
assignment = {}

# Call DPLL with the CNF formula and initial assignment
current_dpll_times = []
start = time.time()
result = DPLL(cnf, assignment)
stop = time.time()
current_dpll_times.append(stop-start)
print (current_dpll_times)'''

# Print the result and collected data
#Found True 
if result is not None:
    #making Graph
    plt.figure(figsize=(10, 6))
    plt.scatter(max_satisfied_clauses_list, current_dpll_times_list)
    plt.xlabel('Max Satisfied Clauses')
    plt.ylabel('Time (seconds)')
    plt.title('DPLL Performance')
    plt.show()
else: #Found False
    print("No satisfying assignment found.")
